{{>partial_header}}
package {{packageName}}

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"
)

var (
	logUserAgent bool = false
	logGetStatus bool = false
)

func init() {
	logUserAgentStr, ok := os.LookupEnv("LOG_USER_AGENT")
	if ok {
		var err error
		logUserAgent, err = strconv.ParseBool(logUserAgentStr)
		if err != nil {
			logUserAgent = false
		}
	}
	logGetStatusStr, ok := os.LookupEnv("LOG_STATUS")
	if ok {
		var err error
		logGetStatus, err = strconv.ParseBool(logGetStatusStr)
		if err != nil {
			logGetStatus = false
		}
	}
}

/*
  StatusRecorder is a wrapper around http.ResponseWriter. It delegates all interface methods to its inner http.ResponseWriter but captures the status code in WriteHeader to extract it after the handler is called.
*/
type StatusRecorder struct {
	Writer http.ResponseWriter
	Status int
}

func (r *StatusRecorder) WriteHeader(status int) {
	r.Status = status // Capture the status
	r.Writer.WriteHeader(status)
}

func (r *StatusRecorder) Write(b []byte) (int, error) {
	return r.Writer.Write(b) // delegate
}

func (r *StatusRecorder) Header() http.Header {
	return r.Writer.Header() // delegate
}

func Logger(inner http.Handler, name string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		recorder := &StatusRecorder{
			Writer: w,
			Status: 200, // Init the status to 200 if WriteHeader is never called
		}

		var userAgent string
		if logUserAgent && name != "Healthz" {
			userAgent = fmt.Sprintf("User-Agent:%s", strings.ReplaceAll(r.Header.Get("User-Agent"), " ", "_"))
		}

		inner.ServeHTTP(recorder, r)

		if name != "Healthz" && (name != "Status" || logGetStatus) {
			log.Printf(
				"[%s] [INFO] %s %s %s %s %d %s",
				r.Header.Get("zolara-grpc-token"),
				r.Method,
				r.RequestURI,
				name,
				time.Since(start),
				recorder.Status,
				userAgent,
			)
		}
	})
}
